import { jsx, memo, Fragment, isValidElement, cloneElement } from './base';
import { ErrorBoundary } from './components';
import { createContext, useContext } from './context';
import { useState, useEffect, useRef, useCallback, use, startTransition, useTransition, useDeferredValue, startViewTransition, useViewTransition, useMemo, useLayoutEffect, useReducer, useId, useDebugValue } from './hooks';
import { Suspense } from './streaming';
export { jsx, memo, Fragment, isValidElement, jsx as createElement, cloneElement, ErrorBoundary, createContext, useContext, useState, useEffect, useRef, useCallback, useReducer, useId, useDebugValue, use, startTransition, useTransition, useDeferredValue, startViewTransition, useViewTransition, useMemo, useLayoutEffect, Suspense, };
declare const _default: {
    memo: <T>(component: import("./base").FC<T>, propsAreEqual?: (prevProps: Readonly<T>, nextProps: Readonly<T>) => boolean) => import("./base").FC<T>;
    Fragment: ({ children, }: {
        key?: string | undefined;
        children?: import("../utils/html").HtmlEscapedString | import("./base").Child;
    }) => import("../utils/html").HtmlEscapedString;
    isValidElement: (element: unknown) => element is import("./base").JSXNode;
    createElement: (tag: string | Function, props: import("./base").Props, ...children: (string | import("../utils/html").HtmlEscapedString)[]) => import("./base").JSXNode;
    cloneElement: <T_1 extends import("./base").JSXNode | JSX.Element>(element: T_1, props: Partial<import("./base").Props>, ...children: import("./base").Child[]) => T_1;
    ErrorBoundary: import("./base").FC<import("./types").PropsWithChildren<{
        fallback?: import("./base").Child;
        fallbackRender?: import("./components").FallbackRender | undefined;
        onError?: import("./components").ErrorHandler | undefined;
    }>>;
    createContext: <T_2>(defaultValue: T_2) => import("./context").Context<T_2>;
    useContext: <T_3>(context: import("./context").Context<T_3>) => T_3;
    useState: <T_4>(initialState: T_4 | (() => T_4)) => [T_4, (newState: T_4 | ((currentState: T_4) => T_4)) => void];
    useEffect: (effect: () => void | (() => void), deps?: readonly unknown[] | undefined) => void;
    useRef: <T_5>(initialValue: T_5 | null) => import("./hooks").RefObject<T_5>;
    useCallback: <T_6 extends (...args: unknown[]) => unknown>(callback: T_6, deps: readonly unknown[]) => T_6;
    useReducer: <T_7, A>(reducer: (state: T_7, action: A) => T_7, initialArg: T_7, init?: ((initialState: T_7) => T_7) | undefined) => [T_7, (action: A) => void];
    useId: () => string;
    useDebugValue: (_value: unknown, _formatter?: ((value: unknown) => string) | undefined) => void;
    use: <T_8>(promise: Promise<T_8>) => T_8;
    startTransition: (callback: () => void) => void;
    useTransition: () => [boolean, (callback: () => void) => void];
    useDeferredValue: <T_9>(value: T_9) => T_9;
    startViewTransition: (callback: () => void) => void;
    useViewTransition: () => [boolean, (callback: () => void) => void];
    useMemo: <T_10>(factory: () => T_10, deps: readonly unknown[]) => T_10;
    useLayoutEffect: (effect: () => void | (() => void), deps?: readonly unknown[] | undefined) => void;
    Suspense: import("./base").FC<import("./types").PropsWithChildren<{
        fallback: any;
    }>>;
};
export default _default;
export * from './types';
